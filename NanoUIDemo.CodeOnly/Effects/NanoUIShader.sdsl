
shader NanoUIShader : ShaderBase 
{
    matrix proj;
    stage Texture2D tex;

    SamplerState TexSampler {
        Filter = MIN_MAG_MIP_LINEAR;
        AddressU = Clamp;
        AddressV = Clamp;
        MaxAnisotropy = 1;
    };

    cbuffer PS_CONSTANTS
    {
        float4x4 scissorMat;
        float4x4 paintMat;
        float4 innerCol;
        float4 outerCol;
        float2 scissorExt;
        float2 scissorScale;
        
        float2 extent;
        float radius;
        float feather;
        
        float actionType;
        float fontSize;
        float unused1;
        float unused2;
    };
    
    stream float2 fpos       : POSITION;      // float 2 position 
    stream float2 ftcoord    : TEXCOORD0;     // float 2 tex coord

    override stage void VSMain() 
    {
        // Stride: column-major, use mul(vector, matrix)
        streams.ShadingPosition = mul(float4(streams.fpos, 0.0, 1.0f), proj);
    }

    override stage void PSMain() 
    {
        float4 result;
        float scissor = scissorMask(streams.fpos);
        float strokeAlpha = 1.0f;

        if (actionType == 0) 
        {
            // Gradient fill
            float2 pt = (mul(float4(streams.fpos,0,1.0), paintMat)).xy;
            float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
            float4 color = lerp(innerCol, outerCol, d);
            color *= strokeAlpha * scissor;
            result = color;
        }
        else if (actionType == 1)
        {
            // Image fill (premultiplied)
            float2 pt = (mul(float4(streams.fpos,0,1.0), paintMat)).xy / extent;
            float4 color = tex.Sample(TexSampler, pt);
            color = float4(color.xyz*color.w,color.w);
            if(innerCol.r != 0 || innerCol.g != 0 || innerCol.b != 0 || innerCol.a != 0)
            {
                color *= innerCol;
            }
            color *= strokeAlpha * scissor;
            result = color;
        }
        else if (actionType == 2)
        {
            // Stencil fill (color ignored by pipeline)
            result = float4(1,1,1,1);
        } 
        else if (actionType == 3)
        {
            // Normal text (font atlas in R)
            float col = tex.Sample(TexSampler, streams.ftcoord).x;
            float4 color = float4(col, col, col, col);
            color *= scissor;
            result = (color * innerCol);
        }
        else // actionType == 4 (SDF text)
        {
            float distance = tex.Sample(TexSampler, streams.ftcoord).x;
            float weight = 0.5;
            float smoothing = clamp(4.0 / fontSize, 0.0, 0.5);
            float alpha = smoothstep(weight - smoothing, weight + smoothing, distance);
            result = float4(innerCol.xyz, innerCol.w * alpha) * scissor;
        }
        streams.ColorTarget = result;
    }

    float sdroundrect(float2 pt, float2 ext, float rad) 
    {
        float2 ext2 = ext - float2(rad,rad);
        float2 d = abs(pt) - ext2;
        return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
    }
    
    // Scissoring
    float scissorMask(float2 p) 
    {
        float2 sc = (abs((mul(float4(p.x, p.y,0, 1.0), scissorMat)).xy) - scissorExt);
        sc = float2(0.5,0.5) - sc * scissorScale;
        return clamp(sc.x,0.0,1.0) * clamp(sc.y,0.0,1.0);
    }
};
