shader NanoUIShader : ShaderBase 
{
    matrix proj;
    stage Texture2D tex;

    SamplerState TexSampler {
        Filter = MIN_MAG_MIP_LINEAR;
        AddressU = Clamp;
        AddressV = Clamp;
        MaxAnisotropy = 1;
    };

    cbuffer PS_CONSTANTS
    {
        float4x4 scissorMat;
        float4x4 paintMat;
        float4 innerCol;
        float4 outerCol;
        float2 scissorExt;
        float2 scissorScale;
        
        float2 extent;
        float radius;
        float feather;
        
        float actionType;
        float fontSize;
        float unused1; // used as debug flag when > 0.5f
        float unused2;
    };
    
    stream float2 fpos       : POSITION;      // float 2 position 
    stream float2 ftcoord    : TEXCOORD0;     // float 2 tex coord (normalized)

    override stage void VSMain() 
    {
        streams.ShadingPosition = mul(float4(streams.fpos, 0.0, 1.0f), proj);
    }

    float sdroundrect(float2 pt, float2 ext, float rad) 
    {
        float2 ext2 = ext - float2(rad,rad);
        float2 d = abs(pt) - ext2;
        return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rad;
    }
    
    float scissorMask(float2 p) 
    {
        float2 sc = (abs(mul(float4(p,0, 1.0), scissorMat).xy) - scissorExt);
        sc = float2(0.5,0.5) - sc * scissorScale;
        return saturate(sc.x) * saturate(sc.y);
    }

    override stage void PSMain() 
    {
        bool debug = (unused1 > 0.5f);

        float4 result;
        float scissor = debug ? 1.0 : scissorMask(streams.fpos);
        float strokeAlpha = 1.0f;

        if (actionType == 0) 
        {
            float2 pt = mul(float4(streams.fpos,0,1.0), paintMat).xy;
            float d = clamp((sdroundrect(pt, extent, radius) + feather*0.5) / feather, 0.0, 1.0);
            float4 color = lerp(innerCol, outerCol, d);
            color *= strokeAlpha * scissor;
            result = color;
        }
        else if (actionType == 1)
        {
            float2 pt = mul(float4(streams.fpos,0,1.0), paintMat).xy / max(extent, 1e-6);
            float4 color = tex.Sample(TexSampler, pt);
            color = float4(color.rgb * color.a, color.a);
            if(any(innerCol))
            {
                color *= innerCol;
            }
            color *= strokeAlpha * scissor;
            result = color;
        }
        else if (actionType == 2)
        {
            result = float4(1,1,1,1);
        } 
        else if (actionType == 3)
        {
            float a = tex.Sample(TexSampler, streams.ftcoord).r;
            if (debug)
            {
                result = float4(a, a, a, 1.0) * scissor; // visualize sampled alpha
            }
            else
            {
                // innerCol is already premultiplied by global alpha on CPU; modulate by coverage only
                float3 rgb = innerCol.rgb * a;
                float alpha = innerCol.a * a;
                result = float4(rgb, alpha) * scissor;
            }
        }
        else // actionType == 4 (SDF)
        {
            float distance = tex.Sample(TexSampler, streams.ftcoord).r;
            if (debug)
            {
                result = float4(distance, distance, distance, 1.0) * scissor; // visualize SDF distance
            }
            else
            {
                float weight = 0.5;
                float smoothing = clamp(4.0 / max(fontSize, 0.0001), 0.0, 0.5);
                float coverage = smoothstep(weight - smoothing, weight + smoothing, distance);
                float3 rgb = innerCol.rgb * coverage;
                float alpha = innerCol.a * coverage;
                result = float4(rgb, alpha) * scissor;
            }
        }
        streams.ColorTarget = result;
    }
};
